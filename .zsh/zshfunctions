# colorizing the output of make
if [[ -x ~/bin/makefilter ]]
then
        M() { command make "$@" |& makefilter }
fi

# # clean directory
function purge()
{
	FILES=(*~(N) .*~(N) \#*\#(N) *.o(N) a.out(N) *.core(N) *.cmo(N) *.cmi(N) .*.swp(N))
	NBFILES=${#FILES}
	if [[ $NBFILES > 0 ]]; then
		print $FILES
		local ans
		echo -n "Remove this files? [y/n] "
		read -q ans
		if [[ $ans == "y" ]]
		then
			rm ${FILES}
			echo ">> $PWD purged, $NBFILES files removed"
		else
			echo "Ok. .. than not.."
		fi
	fi
}

# Name (``hash -d'') all the subdirectories in given directory
# $ mkdir -p foo/{bar,foo,fnord,recursion}
# $ quick-hash foo
# $ hash -d
# bar=foo/bar
# fnord=foo/fnord
# foo=foo/foo
# recursion=foo/recursion
function quick-hash()
{
	for i in $1/*(/); do
		hash -d ${i##*/}=$i
	done
}

# print current settings of LC_*
function plocale()
{
	print LC_ALL=$LC_ALL
	print LANG=$LANG
	print LC_CTYPE=$LC_CTYPE
	print LC_NUMERIC=$LC_NUMERIC
	print LC_TIME=$LC_TIME
	print LC_COLLATE=$LC_COLLATE
	print LC_MONETARY=$LC_MONETARY
	print LC_MESSAGES=$LC_MESSAGES
	print LC_PAPER=$LC_PAPER
	print LC_NAME=$LC_NAME
	print LC_ADDRESS=$LC_ADDRESS
	print LC_TELEPHONE=$LC_TELEPHONE
	print LC_MEASUREMENT=$LC_MEASUREMENT
	print LC_IDENTIFICATION=$LC_IDENTIFICATION
}

# invoke this every time when u change .zshrc to recompile it.
function src()
{
	autoload -U zrecompile
		[ -f ~/.zshrc ] && zrecompile -p ~/.zshrc
		[ -f ~/.zcompdump ] && zrecompile -p ~/.zcompdump
		[ -f ~/.zcompdump ] && zrecompile -p ~/.zcompdump
		[ -f ~/.zshrc.zwc.old ] && rm -f ~/.zshrc.zwc.old
		[ -f ~/.zcompdump.zwc.old ] && rm -f ~/.zcompdump.zwc.old
		source ~/.zshrc
}

# Happy CVS'ing
function cvsd() { cvs diff -N $* |& $PAGER }
function cvsl() { cvs log $* |& $PAGER }
function cvsr() { rcs2log $* | $PAGER }
function cvss() { cvs status -v $* }
function cvsq() { cvs -nq update }
function cvsa() { cvs add $* && cvs com -m 'initial checkin' $* }

# Some quick Perl-hacks aka /useful/ oneliner
function bew() { perl -e 'print unpack "B*","'$1'"' ; perl -e 'print "\n"' }
#function web() { perl -e 'print pack "B*","'$1'"' ; perl -e 'print "\n"' }
function hew() { perl -e 'print unpack "H*","'$1'"' ; perl -e 'print "\n"' }
function weh() { perl -e 'print pack "H*","'$1'"' ; perl -e 'print "\n"' }
function pversion() { perl -M$1 -le "print $1->VERSION" } # i. e."pversion LWP -> 5.79"
function getlinks () { perl -ne 'while ( m/"((www|ftp|http):\/\/.*?)"/gc ) { print $1, "\n"; }' $* }
function gethrefs () { perl -ne 'while ( m/href="([^"]*)"/gc ) { print $1, "\n"; }' $* }
function getanames () { perl -ne 'while ( m/a name="([^"]*)"/gc ) { print $1, "\n"; }' $* }
function getforms () { perl -ne 'while ( m:(\</?(input|form|select|option).*?\>):gic ) { print $1, "\n"; }' $* }
function getstrings () { perl -ne 'while ( m/"(.*?)"/gc ) { print $1, "\n"; }' $*}
function getanchors () { perl -ne 'while ( m/«([^«»\n]+)»/gc ) { print $1, "\n"; }' $* }
function showINC () { perl -e 'for (@INC) { printf "%d %s\n", $i++, $_ }' }
function vimpm () { vim `perldoc -l $1 | sed -e 's/pod$/pm/'` }
function vimhelp () { vim -c "help $1" -c on -c "au! VimEnter *" }

# set the DISPLAY to where i'm logged from or - if an argument is specified -
# to the value of the argument
function disp()
{
	if [[ $# == 0 ]]; then
		DISPLAY=$(who am i | awk '{print $6}' | tr -d '()'):0
	else
		DISPLAY="${*}:0"
	fi
	export DISPLAY
}

# adds a directory to the PATH, without making duplicate entries
function add_to_path()
{
	if [[ "$1" == "" ]]; then
		echo "Usage: $0 directory"
	else
		unset SPACEPATH
		local SPACEPATH
		for i in  ${(s.:.)PATH}; do
			SPACEPATH=( $SPACEPATH $i )
		done
		typeset -U SPACEPATH
		if [[ -d "$1" ]]; then; SPACEPATH=( $SPACEPATH "$1" ); fi
		PATH="`echo $SPACEPATH`"
		PATH=${PATH:gs/ /:/}
		export PATH
		rehash
	fi
}

# Shameless stolen from Sven Guckes (<http://www.guckes.net/setup/zshrc.mine>)
# _lap foo -- list all programs with prefix "foo":
function _lap()
{
        if [[ $# = 0 ]]
        then
                echo "Usage:    $0 program"
                echo "Example:  $0 zsh"
                echo "Lists all occurrences of program in the current PATH."
        else
		ls -l ${^path}/*$1*(*N)
	fi
}

# A life without 'diff'? Unimaginably!!!!11!
function mdiff() { diff -udrP "$1" "$2" > diff.`date "+%Y-%m-%d"`."$1" }
function udiff() { diff -urd $* | egrep -v "^Only in |^Binary files " }
function cdiff() { diff -crd $* | egrep -v "^Only in |^Binary files " }

# List / Search / Browse in a archive without unpack
function lynxbzgrep() { lynx -force_html -dump =(bzip2 -cd $1) | grep -i $2 }
function browse-archive() { lynx -force_html <( gzip -cd $1 ) }

# mkdir && cd
function mcd() { mkdir "$1"; cd "$1" }

# $ ls -l =ls
# $ -r-xr-xr-x    1 root     bin        167936 Oct  4  2002 /bin/ls
# $ pls ls
# $ -r-xr-xr-x    1 root     bin        167936 Oct  4  2002 /bin/ls
function pls() { ls -l =$1 }

# cd && ls
function cl() { cd $1 && ls -a }

# Often needed (if i rape '$LS_COLORS' again *g*)
function _cols()
{
	esc="\033["
	echo -e "       40      41      42      43      44      45      46      47      00"
	for fore in 30 31 32 33 34 35 36 37; do
		line1="$fore  "
		line2="    "
		for back in 40 41 42 43 44 45 46 47 00; do
			line1="${line1}${esc}${back};${fore}m Normal ${esc}0m"
			line2="${line2}${esc}${back};${fore};1m Bold   ${esc}0m"
		done
		echo -e "$line1\n$line2"
	done
}

# Usage: simple-extract <file>
# Description: extracts archived files (maybe)
simple-extract ()
{
        if [[ -f $1 ]]
        then
                case $1 in
                        *.tar.bz2)  bzip2 -d $1         ;;
                        *.tar.gz)   tar -xvzf $1        ;;
                        *.rar)      unrar $1            ;;
                        *.deb)      ar -x $1            ;;
                        *.bz2)      bzip2 -d $1         ;;
                        *.lzh)      lha x $1            ;;
                        *.gz)       gunzip -d $1        ;;
                        *.tar)      tar -xvf $1         ;;
                        *.tgz)      gunzip -d $1        ;;
                        *.tbz2)     tar -jxvf $1        ;;
                        *.zip)      unzip $1            ;;
                        *.Z)        uncompress $1       ;;
                        *)          echo "'$1' Error. Please go away" ;;
                esac
        else
                echo "'$1' is not a valid file"
        fi
}

# Usage: show-archive <archive>
# Description: view archive without unpack
show-archive()
{
        if [[ -f $1 ]]
        then
                case $1 in
                        *.tar.gz)      gunzip -c $1 | tar -tf - -- ;;
                        *.tar)         tar -tf $1 ;;
                        *.tgz)         tar -ztf $1 ;;
                        *.zip)         unzip -l $1 ;;
                        *.bz2)         bzless $1 ;;
                        *)             echo "'$1' Error. Please go away" ;;
                esac
        else
                echo "'$1' is not a valid archive"
        fi
}

# find process and kill it
morons() { reply=(`ps ax | grep -v COMMAND |perl -nle '@a=split(" ",$_,9);$_=$a[4];s/[()]//g;s/.*\///g;print'`) }
compctl -K morons pskill pkill
pskill()
{
	local signal="HUP"
	if [[ $1 == "" || $3 != "" ]]; then
		print "Usage: $0 processname [signal]" && return 1
	fi
	[[ $2 != "" ]] && signal=$2
	set -A pids $(command ps wwaux | grep $1 | grep -v "grep $1" | awk '{ print $2 }')
	if [[ ${#pids} -lt 1 ]]; then
		print "No matching processes for »$1«" && return 1
	fi
	if [[ ${#pids} -gt 1 ]]; then
		print "${#pids} processes matched: $pids"
		read -q "?Kill all? [y/n] " || return 0
	fi
	if kill -$signal $pids; then
		echo "Killed $1 pid $pids with SIG$signal"
	fi
}

# Use 'view' to read manpages, if u want colors, regex - search, ...
# like vi(m).
# It's shameless stolen from <http://www.vim.org/tips/tip.php?tip_id=167>
function vman() { man $* | col -b | view -c 'set ft=man nomod nolist' - }

# Exchange ' ' for '_' in filenames.
unspaceit()
{
	for _spaced in "${@:+"$@"}"; do
		if [ ! -f "${_spaced}" ]; then
			continue;
		fi
		_underscored=$(echo ${_spaced} | tr ' ' '_');
		if [ "${_underscored}" != "${_spaced}" ]; then
			mv "${_spaced}" "${_underscored}";
		fi
	done
}

# make screenshot of current desktop (use 'import' from ImageMagic)
# See man date(1) and man import(1) for details.
# Note: If you don't have 'import', install ImageMagick and stop
#       crying.
function sshot()
{
	[[ ! -d ~/shots  ]] && mkdir ~/shots
	cd ~/shots && sleep 5; import -window root `date "+%Y-%m-%d%--%H:%M:%S"`.jpg
}

# Needs ImageMagick
function gif2png()
{
	if [[ $# = 0 ]]
	then
		echo "Usage: $0 foo.gif"
		echo "Purpose: change a GIF file to a PNG file"
	else
		output=`basename $1 .gif`.png
		convert  $1 $output
		touch -r $1 $output
		ls -l $1 $output
	fi
}

# search for various types or README file in dir and display them in $PAGER
# function readme() { $PAGER -- (#ia3)readme* }
function readme()
{
	local files
	files=(./(#i)*(read*me|lue*m(in|)ut)*(ND))
	if (($#files))
	then $PAGER $files
	else
		print 'No README files. Please lart \$MAINTAINER!'
	fi
}

# find all suid files in $PATH
function suidfind() { ls -latg ${(s.:.)PATH} | grep '^...s' }

# See above but this is /better/ ... anywise ..
#  Note: Add $USER and 'find' with "NOPASSWD" in your /etc/sudoers or run it
#        as root (UID == 0)
function findsuid()
{
        sudo find / -type f \( -perm -4000 -o -perm -2000 \) -ls > ~/.suid/suidfiles.`date "+%Y-%m-%d"`.out 2>&1
        sudo find / -type d \( -perm -4000 -o -perm -2000 \) -ls > ~/.suid/suiddirs.`date "+%Y-%m-%d"`.out 2>&1
        sudo find / -type f \( -perm -2 -o -perm -20 \) -ls > ~/.suid/writefiles.`date "+%Y-%m-%d"`.out 2>&1
        sudo find / -type d \( -perm -2 -o -perm -20 \) -ls > ~/.suid/writedirs.`date "+%Y-%m-%d"`.out 2>&1
}

# csh compatibility
setenv() { typeset -x "${1}${1:+=}${(@)argv[2,$#]}" }

# Add directory to a bookmark-list
# % bmadd       # add directory to bookmark list
# % bmls        # show list of bookmark list
# % bmvi        # edit bookmark list
# % bm $NUMBER  # change directory to $NUMBER bookmark
BMRC=~/.bmrc
touch $BMRC
bmls() { cat $BMRC | sort -n}
bmvi() { vi $BMRC }
bmadd() {
        local bmdir=`pwd`
        local newid=$1
        local bmname=''
        for bmname in `bm_path_list`
        do
                if [ "$bmname" = "$bmdir" ]; then
                        echo "$bmdir is already in bm list"
                        return
                fi
        done
        if [ -z $newid ]; then
                maxid=`cat $BMRC | cut -f 1 | sort -n -r | head -1`
                if [ "$maxid" -ge 1 ]; then
                        newid=`expr 0$maxid + 1`
                else
                        newid=1
                fi
        fi
        echo "$newid\t$bmdir" >> $BMRC
}
bm() {
        local num=$1
        local bmdir=`bm_get $num`
        if [ -z "$bmdir" ]; then
                bmls
                [ -z "$num" ] || echo "$num is not in bm list"
                return
        fi
        cd "$bmdir"
}
bm_get() {
        local bmdir=`cat $BMRC | egrep "^${1}[[:space:]]" | cut -f 2`
        echo $bmdir
}

bm_path_list() {
        cut -f 2 < $BMRC
}

# Temporary (interactive) removes. Alternative to this u can use
# http://www.strcat.de/hacks/rm-replacements.shar
function rf()
{
        [[ -z ${SHITDIR} ]] && print "No ${SHITDIR} defined." && return 1
        [[ ! -d ${SHITDIR} ]] && mkdir ${SHITDIR}
        mv $* ${SHITDIR}
}

# Reload functions.
function refunc()
{
	for func in $argv; do
		unfunction $func
		autoload $func
	done
}


# Find (and print) all symbolic links without a target within the
# current directorytree (i. e. ll symlinks that dont point to files,
# directories, sockets, devices, or named pipes).
# Note: all three functions works but the last is nicer
# function brlinks() { for i in **/*(D@); [[ -f $i || -d $i ]] || echo $i }
# function brlinks() { print -l **/*(@-^./=%p) }
function brlinks() { print -l **/*(-@) }


function mkiso()
{
	echo " * Volume name "
	read volume
	echo " * ISO Name (ie. tmp.iso)"
	read iso
	echo " * Directory or File"
	read files
	mkisofs -o ~/$iso -A $volume -allow-multidot -J -R -iso-level 3 -V $volume -R $files
}

# rmmodcomplete() looks for modules in memory, for use with "rmmod".
rmmodcomplete () { reply=(`/sbin/lsmod|cut -f1 -d" "|grep -v Module`) }
compctl -K rmmodcomplete rmmod

# insmodcomplete() looks for modules to use with "insmod" or
# "modprobe".
function insmodcomplete() { reply=(`find /lib/modules/$(uname -r)/* ! -type d -printf "%f\n"|sed "s/\.o$//"`) }
compctl -K insmodcomplete insmod modprobe


# Complete a howto-filename or FAQ-name (see howto script below).
# Use like "howto zsh[TAB]".
function howtocomplete() { reply=(`howto --find "$1"`) }
compctl -U -K howtocomplete howto
p0rncomplete() { reply=(`p0rn --find "$1"`) }
compctl -U -K p0rncomplete p0rn

