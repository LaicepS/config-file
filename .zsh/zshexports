# (( ${+*} )) = if variable is set don't set it anymore
#  Note: Do *not* use '$PORTSDIR'! This variable is defined in
#        '/path/to/ports/Makefile'.
(( ${+BROWSER} )) || export BROWSER="google-chrome"
(( ${+OS} )) || export OS="${OSTYPE%%[0-9.]*}"
(( ${+OSVERSION} )) || export OSVERSION="${OSTYPE#$OS}"
(( ${+OSMAJOR} )) || export OSMAJOR="${OSVERSION%%.*}"
(( ${+SHITDIR} )) || export SHITDIR="/home/$LOGNAME/Trash"

# Set the values for some environment variables:
export HOSTNAME="`hostname -s`"
export LESS="-sCieM -P?fFile %f:stdin. ?m(%i of %m) :.line %l ?Lof %L:.?p (%p\%):."
export LESS="-R"
export LESSBINFMT='*u[%X]'
export LESSOPEN="|lesspipe.sh %s"
export PAGER=less
export CVS_RSH=ssh
#export CVSROOT="@:/home/cvs"
#export HELPDIR='~/.zsh/help'
#export VERSION=${VERSION:-"zsh $ZSH_VERSION"}
export WWW_HOME="http://www.google.com"
export HTTP_HOME="http://www.google.com"
#export INFOPATH="/usr/local/info/:/usr/share/info/:/usr/local/emul/redhat/:/usr/share/info/"
#export MANWIDTH=80

# i primarily use Vim (GNU Emacs and jed are only exception ;-))
#  $ print ${${$(=vim --version)[5]}:gs/.//}
# is equivalent to
#  $ /path/to/vim --version | head -n 1 | awk '{print $5}' | sed 's/\.//'
if [ -x $(which gvim) ]; then
	export EDITOR=gvim
	export VISUAL="${EDITOR}"
	export VIMRELEASE="`print ${${$(vim --version)[5]}:gs/.//}`"
fi

case ${OS} in
	openbsd)
	[ -d "/usr/local/share/vim/vim$VIMRELEASE" ] \
		&& export VIMRUNTIME="/usr/local/share/vim/vim$VIMRELEASE"
	;;
	netbsd)
	[ -d "/usr/pkg/share/vim/vim$VIMRELEASE" ] \
		&& export VIMRUNTIME="/usr/pkg/share/vim/vim$VIMRELEASE"
	;;
	linux-gnu)
	[ -d "/usr/share/vim/vim$VIMRELEASE" ] \
		&& export VIMRUNTIME="/usr/share/vim/vim$VIMRELEASE"
	;;
esac

export LIBCFG_DBFILE="/home/ace/projects/libs.txt"

# # OpenBSD doesn't support locale!
# if [ "${OSTYPE}" = linux-gnu ] && [ -x $(which locale) ]; then
#         export LC_ALL=
#         export LANG="fr_FR@euro"
#         export LC_CTYPE="fr_FR@euro"
#         export LC_NUMERIC="fr_FR@euro"
#         export LC_TIME="fr_FR@euro"
#         export LC_COLLATE=POSIX
#         export LC_MONETARY="fr_FR@euro"
#         export LC_MESSAGES=POSIX
#         export LC_PAPER="fr_FR@euro"
#         export LC_NAME="fr_FR@euro"
#         export LC_ADDRESS="fr_FR@euro"
#         export LC_TELEPHONE="fr_FR@euro"
#         export LC_MEASUREMENT="fr_FR@euro"
#         export LC_IDENTIFICATION="fr_FR@euro"
# else
#         export LC_ALL=POSIX
# fi



# $ cd /usr/ports/misc/fileutils
# $ make install clean
#  di = directory
#  fi = file
#  ln = symbolic link
#  pi = fifo file
#  so = socket file
#  bd = block (buffered) special file (block device)
#  cd = character (unbuffered) special file (character device)
#  or = symbolic link pointing to a non-existent file (orphan)
#  mi = non-existent file pointed to by a symbolic link (visible when you type ls -l)
#  ex = file which is executable (ie. has 'x' set in permissions (executable)).
#
# 0   = default color                   1   = bold
# 4   = underlined                      5   = flashing text
# 7   = reverse field                   31  = red
# 32  = green                           33  = orange
# 34  = blue                            35  = purple
# 36  = cyan                            37  = grey
# 40  = black background                41  = red background
# 42  = green background                43  = orange background
# 44  = blue background                 45  = purple background
# 46  = cyan background                 47  = grey background
# 90  = dark grey                       91  = light red
# 92  = light green                     93  = yellow
# 94  = light blue                      95  = light purple
# 96  = turquoise                       100 = dark grey background
# 101 = light red background            102 = light green background
# 103 = yellow background               104 = light blue background
# 105 = light purple background         106 = turquoise background
#
# Attribute codes:
#  00 none
#  01 bold
#  02 faint                  22 normal
#  03 standout               23 no-standout
#  04 underline              24 no-underline
#  05 blink                  25 no-blink
#  07 reverse                27 no-reverse
#  08 conceal
#
# export LS_COLORS="fi=36:di=36:ln=1;33:ec=\\e[0;37m:ex=1:mi=1;30:or=1;30:*.c=32:*.bz=32:*.txt=36;1:*.doc=37:*.zip=1;32:*.rar=1;32:*.lzh=1;32:*.lha=1;32:*.arj=1;32:*.tar=1;32:*.tgz=1;32:*.gz=1;32:*~=1;30:*.bak=1;30:*.jpg=1;35:*.gif=1;35:*.tif=1;35:*.tiff=1;35:*.mod=1;31:*.voc=1;31:*.smp=1;31:*.au=1;31:*.wav=1;31:*.s3m=1;31:*.xm=1;31:*.pl=1;33:*.c=1;33"
export LS_COLORS=':*FAQ=31;7:*INSTALL=31;7:*README=31;7:*.sh=47;31:*.sl=30;33:*.swp=00;44;37:*,v=5;34;93:*.vim=35:no=0:fi=0:di=36:ln=36:or=1;40:mi=1;40:pi=31:so=33:bd=44;37:cd=44;37:ex=35:*.jpg=1;32:*.jpeg=1;32:*.JPG=1;32:*.gif=1;32:*.png=1;32:*.jpeg=1;32:*.ppm=1;32:*.pgm=1;32:*.pbm=1;32:*.h=1;33:*.awk=1;33:*.pl=1;33:*.gz=31:*.tar=31:*.zip=31:*.lha=1;31:*.lzh=1;31:*.arj=1;31:*.bz2=31:*.tgz=31:*.taz=1;31:*.html=36:*.htm=1;34:*.doc=1;34:*.txt=1;34:*.o=1;36:*.a=1;36'
export LS_COLORS=":*.c=1;32:*.cpp=1;32:*.d=1;33$LS_COLORS"
export LS_COLORS=":*.bmp=1;32:*.png=1;32$LS_COLORS"

# The format of login / logout reports if the watch parameter is set.
# Default is `%n has %a %l from %m'.
# Recognizes the following escape sequences:
#   %n = name of the user that logged in/out.
#   %a = observed action, i.e. "logged on" or "logged off".
#   %l = line (tty) the user is logged in on.
#   %M = full hostname of the remote host.
#   %m = hostname up to the first `.'.
#   %t or %@ = time, in 12-hour, am/pm format.
#   %w = date in `day-dd' format.
#   %W = date in `mm/dd/yy' format.
#   %D = date in `yy-mm-dd' format.
# WATCHFMT='%n %a %l from %m at %t.'
# WATCHFMT='*knock* *knock* Follow the white rabbit => %n %a %l from %m at %t.'
# WATCHFTM=print '\e[1;35m%B[%b\e[1;32m%B%n%b\e[1;35m%B]%b \e[1;34m%U%a%u \e[1;35mfrom terminal \e[1;31m%M \e[1;35mat \e[1;33m%U%T%u\e[0m''
#WATCHFMT="[%B%t%b] %B%n%b has %a %B%l%b from %B%M%b"
WATCHFMT="%B->%b %n has just %a %(l:tty%l:%U-Ghost-%u)%(m: from %m:)"

# If this parameter is nonzero, the shell will receive an ALRM signal if a
# command is not entered within the specified number of seconds after issuing a
# prompt. If there is a trap on SIGALRM, it will be executed and a new alarm is
# scheduled using the value of the TMOUT parameter after executing the trap.
#TMOUT=1800

# format of process time reports with 'time'
#  %%     A `%'.
#  %U     CPU seconds spent in user mode.
#  %S     CPU seconds spent in kernel mode.
#  %E     Elapsed time in seconds.
#  %P     The CPU percentage, computed as  (%U+%S)/%E.
#  %J     The name of this job.
# Default is:
#       %E real  %U user  %S system   %P  %J
TIMEFMT="Real: %E User: %U System: %S Percent: %P Cmd: %J"

# The maximum number of events stored in the internal history list. If you use
# the HIST_EXPIRE_DUPS_FIRST option, setting this value larger than the
# SAVEHIST size will give you the difference as a cushion for saving
# duplicated history events.
HISTSIZE=100000

# Stop annoying MailChecks. I'm not using AOL
unset MAILCHECK

# The name of the file used to store command history. When assigned to, history
# is loaded from the specified file. Also, several invocations of the shell
# running on the same machine will share history if their HISTFILE parameters
# all point to the same file.
# i have finally discovered the difference between `SAVEHIST' and `HISTSIZE'
# thanks to the FAQ. `HISTSIZE' is the number of lines of history that is
# kept within any given, running zsh. `SAVEHIST' is the number of lines of
# history that is written out to a file at the magic, mysterious moment
# when that event occurs. so cat-ing `HISTFILE' into wc -l should enumerate
# the number of history events
HISTFILE=$HOME/.zsh_history
SAVEHIST=65536
DIRSTACKSIZE=50

# If nonnegative, commands whose combined user and system execution
# times (measured in seconds) are greater than this value have timing
# statistics printed for them.
REPORTTIME=10

# Limit this fuckung "zsh: do you wish to see all NNN possibilities (NNN
# lines)?" downward (default is 100). Only ask before displaying
# completions if doing so would scroll.
LISTMAX=0

# Seconds for login / logout check
LOGCHECK=20


# Check some directories and add existing to $PATH
for dir in \
	$HOME/bin \
	$HOME/local/bin \
	/usr/local/bin \
	/usr/lib/news/bin \
	/usr/games
do
	[ -d "${dir}" ] && PATH="${PATH}:${dir}"
done

# For root users, ensure that /usr/local/sbin, /usr/sbin, and /sbin are in
if (( EUID == 0 )); then
	PATH=/sbin:/usr/sbin:/usr/local/sbin:$PATH
fi

# Clean duplicate and non-existing dirs from $PATH before export
path=($^path(N))
export PATH


# if your compdef Dir is ~/.zsh
fpath=( $fpath /usr/local/share/zsh/$ZSH_VERSION/functions/ ~/.zsh/func/ )

# See <http://sugi.nemui.org/doc/zsh/> for details.
#if autoload +X -U _accept_line_with_url > /dev/null 2>&1 ; then
#	zle -N accept-line-with-url _accept_line_with_url
#	bindkey '^M' accept-line-with-ur	bindkey '^J' accept-line-with-url
#	export DOWNLOADER="wget -S"
#fi

# Using firefox as browser when X11 is up
if [ $DISPLAY ]; then
	export WWW_BROWSER="firefox %s"
else
	export WWW_BROWSER=${BROWSER:-lynx}
fi

# automatically remove duplicates from these arrays
typeset -gU path cdpath manpath fpath

# RTFM!!!11!
MANPATH="/usr/share/man:/usr/local/man"
for mdir in \
        /var/qmail/man \
        /usr/X11/man \
        /usr/X11R6/man \
        /usr/contrib/man \
        /usr/share/man/old
do
        [ -d "${mdir}" ] && MANPATH="${MANPATH}:${mdir}"
done


# Specific tab host completion for programs
#hosts=(
#  192.168.10.{1..3}
#  192.168.25.{1,25}
#)
#zstyle ':completion:*:*:(ping|telnet|host|hostx|ssh):*' hosts $hosts


# PS{1,2,3}, RPOMPT, ..
# The "prompt" of the shell.
#  See zshmisc(1) (/PROMPT EXPANSION) for details.
#
# %n         $USERNAME.
# @          literal '@'
# %m         machine name.
# %M         The full machine hostname.
# %%         %
# %/         Present working directory ($PWD) (i. e.: /home/$USERNAME)
# %~         Present working directory ($PWD) (i. e.: ~)
# %h         Current history event number.
# %!         Current history event number.
# %L         The current value of $SHLVL.
# %S (%s)    Start (stop) standout mode.
# %U (%u)    Start (stop) underline mode.
# %B (%b)    Start (stop) boldface mode.
# %t / %@    Current time of day, in 12-hour, am/pm format.
# %T         Current time of day, in 24-hour format.
# %*         Current time of day in 24-hour  format,  with  seconds
# %N         The  name  of  the  script,  sourced file, or shell
#            function that zsh is currently executing,
# %i         The line number currently  being  executed  in  the script
# %w         The date in day-dd format.
# %W         The date in mm/dd/yy format.
# %D         The date in yy-mm-dd format.
# %D{string} string  is  formatted  using the strftime function (strftime(3))
# %l         The line (tty) the user is logged in on
# %?         The  return  code of the last command executed just before the prompt
# %_         The status of the parser
# %E         Clears to end of line
# %#         A  `#'  if  the shell is running with privileges, a `%' if not
# %v         The  value  of the first element of the psvar array parameter
# %{...%}    Include a string as a literal escape sequence
# :          literal ':'
# %Nc        "relative path", ie last N components of $PWD.
# >          literal '>'
#
# You can use ``promptinit'' for the zsh prompt themes extension. See
# ``less ${^fpath}/promptinit(N)'' for details. btw. http://aperiodic.net/phil/prompt/
# is a good prompt introduction for the Z shell


# color from $HOST, red for root
case $HOSTNAME in
	fruneau|barescrimejone|coin)
		# vert
		PROMPT_HOSTCOLOR=$'%{\e[22;32m%}'
		;;
	frankiz|frankiz2|gwennoz|heol|lunedenn|moaz|skinwel|poubelle)
		# violet
		PROMPT_HOSTCOLOR=$'%{\e[22;35m%}'
		;;
	djali|jamlikhet|murphy|yuuai|mnemosyne|xnet|icetea)
		# bleu
		PROMPT_HOSTCOLOR=$'%{\e[22;36m%}'
		;;
	*)
		# blanc
		PROMPT_HOSTCOLOR=$'%{\e[22;37m%}'
		;;
esac

# red for root
if (( EUID == 0 )); then
	PROMPT_USERCOLOR=$'%{\e[01;31m%}'
else
	PROMPT_USERCOLOR=$'%{\e[23;36m%}'
fi

# compile prompt, with red invite on 'exit-Status != 0'
PROMPT_INVITE=$'%{\e[01;33m%}%1~ %(?.%{\e[01;33m%}.%{\e[01;31m%})%# %{\e[00m%}'
PROMPT="${PROMPT_USERCOLOR}%n${PROMPT_HOSTCOLOR}@%m ${PROMPT_INVITE}"


# change right prompt if we're on a distant machine
if [[ $SSH_CLIENT = *.* || $REMOTEHOST = *.* ]]; then
	# add host to the complete path on right
	RPROMPT=$'%{\e[0;36m%}%m:%0~%{\e[00m%}'
	# display ssh informations on title
	TERM_TITLE="%n@%m: %~ [$SSH_CLIENT]"
else
	# show complete path on right
	RPROMPT=$'%{\e[0;36m%}%0~%{\e[00m%}'
	# simple title for terms
	if (( EUID == 0 )); then
		TERM_TITLE="%n@%m: %~"
	else
		TERM_TITLE="%m: %~"
	fi
fi


# Change the title from in xterm/screen
case $TERM in
	xterm|aterm|Eterm)
	if [ -n "$WINDOW" ]; then
		precmd () { print -Pn "\e]0;[screen:$WINDOW] $TERM_TITLE\a" }
	else
		precmd () { print -Pn "\e]0;$TERM_TITLE\a" }
	fi
	;;
esac

# The prompt used for spelling correction. The sequence `%R' expands to
# the string which presumably needs spelling correction, and `%r' expands
# to the proposed correction. All other prompt escapes are also allowed.
SPROMPT=$'%BError!%b Correct %{\e[31m%}%R%{ \e[0m%}to%{ \e[36m%}%r%{ \e[0m%}? [No/Yes/Abort/Edit]: '

